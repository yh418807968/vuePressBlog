[206-反转单链表](https://leetcode-cn.com/problems/reverse-linked-list/)

## 题解

### 代码
```js
// 迭代方案
let cur = head
let prev = null
let next = null
while (cur !== null) {
    next = cur.next // 找到下一个节点
    cur.next = prev // 反转当前节点
    // 将本次数据转为旧数据，准备进入下一次循环
    prev = cur // 当前节点转为旧数据
    cur = next // 获取新节点（下一个节点）作为下一次循环的当前节点
}
return prev
```

### 思路分析
#### 迭代方案
* 在迭代过程中，需要3个指针。保存当前节点cur、上一个节点prev(用于作为当前节点的新的next)、下一个节点next（下一个遍历的节点）

* 从头开始，则cur初始值为head，prev初始值为null，结束条件是`cur === null`

* 主体部分，
* 与环形链表有关的问题，就可以想到快慢指针，就像一个环形跑道，快的跑者一定会和慢的跑者相遇。但这里要注意，生活中的跑步是一个连续变量，所以一定会相遇，但是这里的节点是离散量，所以要注意快慢指针的速度相差要为1，即一个节点，这样单位都是1，也就相当于连续

* 以`fast === slow`结束的情况就是有环，以`fast === null || fast.next === null`就是没有环；所以可以用任一条件作为循环条件，另一条件在内部判断即可

* 由于提前将fast设为了`fast = head.next.next`，所以需要判断`head === null || head.next === null`的情况下范围false

### 复杂度分析
#### 时间复杂度
链表长度为n，复杂度为O(n)
#### 空间复杂度
只用到了有限个指针，空间复杂度为O(1)