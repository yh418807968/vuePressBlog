### 防抖
```js
function debounce (cb, delay) {
	let timer = null
	return function (...args) {
		clearTimerout(timer)
		timer = setTimeout(() => {
			cb.apply(this, args)
		}, delay)
	}
}
```

### 节流——时间戳版本
```js
function throttle (cb, delay) {
	let start = 0
	let timer = null
	return function (...args) {
		let cur = new Date()
		// let res = cur - start
		if (cur - start >= delay) {
			cb.apply(this, args)
			start = cur
		}
	}
}
```

### 节流——定时器版本
```js
function throttle (cb, delay) {
	let timer = null
	return function (...args) {
		if (!timer) {
			timer = setTimeout(() => {
				cb.apply(this, args)
				timer = null
			}, delay)
		}
	}
}
```

### 节流——合并
结合上面两个方案
```js
function throttle (cb, delay) {
	let timer = null
	let start = 0
	return function (...args) {
		let cur = new Date()
		let remaining = delay - (cur - start)
		if (remaining <= 0) { //用于第一次触发时执行
			// 此时有可能有一个已经到时间的timer，为避免重复执行，需要将timer设为null
			if (timer) {
				clearTimerout(timer)
				timer = null
			}
			cb.apply(this, args)
			start = cur
		} else if (!timer){ // 之后每次都会走这儿，这样最后一次也会被执行
			timer = setTimeout(() => {
				cb.apply(this, args)
				timer = null
				start = new Date() // // 【注意二，执行一次cb后，要将start重置】
			}, remaining)
		}
	}
}
```