<!-- ::: tip
待补充
* DNS解析和http报文组装哪个在前面
* DNS的缓存到底有几种（dns-prefetch也可以了解下）
* 一些常用首部可以扩展下
* 各部分分别触发什么事件，loaded和domcontentloaded
* https可以提下，然后链接到https的文章
* 各方法的区别
::: -->


## 前言
本文按时间顺序，并以浏览器进程为贯穿全文的核心脉络，梳理从输入url到页面显示这一过程。
![](https://tva1.sinaimg.cn/large/00831rSTgy1gcquotrl1jj30vq0dawgz.jpg)

## 处理用户输入
> 打开一个新标签页，**浏览器进程**处理用户输入

完整的url由协议、域名、路径和端口号这4部分组成，不过并不需要全部齐全才能被识别为url。浏览器对一些缺失的部分为提供默认值，比如输入baidu.com，浏览器会自动补全为https://www.baidu.com/。
如果判断为一个非url地址，就会利用搜索引擎进行搜索；否则，则进入以下步骤。
以下以url为https://www.baidu.com/为例，进行说明。

## 开始导航
> 用户按下回车键后，浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，并控制 tab 上的 spinner 展现，表示正在加载中。

## 查询资源缓存
如果有缓存资源，那么直接返回资源给浏览器进程，跳过以下的[获取资源步骤](#获取资源)，直接进入后续[渲染步骤](#渲染)；如果在缓存中没有查找到资源，那么直接以下[获取资源步骤](#获取资源)。

（此处涉及到浏览器缓存，内容较多，此处不展开，见[http缓存](../network/http缓存.md)）

## 获取资源
网路进程负责获取网络资源，按照五层因特网协议栈顺序，将经历以下过程：
* 应用层(dns,http) DNS解析成IP并发送http请求
* 传输层(tcp,udp) 建立tcp连接（三次握手）
* 网络层(IP,ARP) IP寻址
* 数据链路层->物理层(PPP) 封装成帧
* 物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）
### DNS解析
DNS解析负责将域名转换为ip地址。首先，检查是否有缓存，有缓存直接使用缓存，没有则进行查询
#### 查看缓存
* 首先，查看浏览器缓存
* 浏览器缓存如果没有，就继续查看本机操作系统缓存
在Windows中可以通过C:\Windows\System32\drivers\etc\hosts文件来设置，在Linux中这个配置是 /etc/hosts。
#### 向域名服务器查询
* 1、向LDNS（本地域名服务器）查询

 LDNS查询自己的缓存，如果存在则返回给客户端；若不存在，则LDNS将充当客户端的角色，向根域名服务器发起一个DNS解析请求。

* 2、LDNS向根域名服务器查询

 根域名服务器是最高级的域名服务器，存储着所有的顶级域名服务器的域名和IP地址。
 根域名服务器将url对应的顶级域名服务器(com)的地址返回给LDNS。

* 3、LDNS向顶级域名服务器查询

 LDNS向顶级域名服务器发起请求，顶级域名服务器将权威域名服务器(baidu.com)的地址返回给LDNS。

* 4、LDNS向权威域名服务器查询

 LDNS向权威域名服务发起请求，权威域名服务查询映射关系表，返回url对应的ip。

* 5、LDNS将结果返回给客户端

 LDNS接收到ip地址后，将ip地址返回给客户端，同时会缓存这个域名和IP的对应关系，以便下次使用。客户端接收到ip后，也会缓存到本地系统中，以便下次使用。

 #### 整体流程
 借用下[一文读懂一个URL请求的过程是怎样的](https://juejin.im/post/5b83b0bfe51d4538c63131a8#heading-11)d的图片
 ![](https://tva1.sinaimg.cn/large/00831rSTgy1gcr7fb0o0nj30lc0bracc.jpg)
 先查看缓存，然后想本地域名服务器发起请求，然后由本地域名服务器代替客户端向远端的域名服务器发起迭代请求，最后将结果返回给客户端。

 ### TCP连接
 http是基于tcp协议的，而tcp是面向连接的，因此在发起http请求之前，要先建立TCP连接。
 以下只简要说明，详细过程可参考[TCP连接的建立和断开](../TCP/TCP连接的建立和断开.md)
 #### 三次握手建立连接
* 客户端：hello，你可以听到吗（SYN=1）？
* 服务端：我可以听到（ACK=1），你可以听到吗（SYN=1）?
* 客户端：我也可以听到（ACK=1）
于是接下来开始愉快的通信了。也就是每一方发起时，对方都需要确认，这样2放一共就需要4次，而接收方的发起和确认可以同时，于是最少需要3次。
 #### 四次挥手断开连接
* 客户端：hello，你要断开了，不再发送消息了（FIN=1）？
* 服务端：好的，我知道了，你断开吧（ACK=1）?
* 服务端：我也要断开了，不再发消息了（FIN=1）
* 客户端：好的，我知道了，你断开吧（ACK=1）
因为一方断开后，另一方仍然可以发送消息，因此断开需要4次，也就是客户端发起->服务端确认，服务端发起->客户端确认。

### 发起http请求和接收http请求
tcp连接后，就可以开始发起http请求了。
#### 报文
HTTP的请求报文与响应报文结构一样，都是分为报文首部和报文主体部分，请求报文中的主体部分主要发送给服务端的数据，而响应报文中的主体则是客户端需要的响应数据。
![](https://tva1.sinaimg.cn/large/00831rSTgy1gcr8ugi5f4j30xg0eowl6.jpg)
报文首部包含：
* 请求行（仅请求报文）: 包含用于请求的方法，请求URI和HTTP版本
* 状态行（仅响应报文）: 包含表明响应结果的状态码，原因短语和HTTP版本
* 首部字段: 包含表示请求和响应的各种条件和属性的各类首部。
![](https://tva1.sinaimg.cn/large/00831rSTgy1gcr8wllf1vj30hb0fb40v.jpg)

**【常见的状态码】**

* 2XX成功：

200 OK客户端请求被服务器正常处理</br>
204 No Content :请求处理成功，但没有资源可返回

* 3XX重定向

302Found 临时重定向，请求的资源已被分配到新的URI。希望用户能使用新的URI访问。</br>
304Not Modified:客户端发送附带条件的请求时，服务器允许请求访问资源，但因发生请求后未满足条件的情况下，直接返回304,返回时不包含任何响应的主体部分。

* 4XX客户端错误

400 Bad Request 请求报文存在语法错误。</br>
401 发送的请求需要有通过HTTP的认证</br>
403 Forbidden 服务器拒绝对请求资源的访问</br>
404 Not Found 服务器上无该资源。网页不存在。</br>

* 5XX 服务器错误

500：服务器内部出现错误</br>
503：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</br>
504：（网关超时）服务器作为网关或代理，但是没有及时从上游服务器收到请求。

浏览器按请求报文格式组装好报文后，便像url对应的服务器发起请求。
#### 发起请求 & 返回结果
数据经过应用层->传输层->网络层->数据链路层->物理层，最终将请求发出；然后又经过物理层->数据链路层->网络层->传输层->应用层传到服务器，服务器端接收到请求，开始处理请求。

服务端根据请求报文处理请求，并将结果返回给客户端，根据资源的不同状况返回对应的状态码。这里也存在缓存机制，具体见[http缓存](../network/http缓存.md)）。

#### 对HTML类型的处理
客户端的网络进程接收到响应头之后，会根据响应头中的 content-type 字段来判断文件的类型。若资源为zip或其他类型，会启动下载；若资源为html类型content-type 的值是“text/html”），则浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程。具体过程如下：

* 浏览器进程接收到网络进程传来的头信息，便想渲染进程发起”提交数据“的消息

* 渲染进程接到消息后，会与网路进程建立传输数据的”管道“

* 渲染进程接收数据完成后(接收过程中会进行渲染，下一节讲到），会返回”完成“的消息给浏览器进程

* 浏览器收到消息后，会**更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面（在此之前页面都还是展示的旧页面）**


## 渲染
> 浏览器进程接收到网络进程的响应头数据之后，浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程，由渲染进程负责渲染页面

### 整体流程
* 1、解析HTML，构建DOM树
* 2、解析CSS，生成CSS规则树
* 3.1、合并DOM树和CSS规则，生成render树
* 3.2、布局render树（Layout/reflow），负责各元素尺寸、位置的计算
* 4、绘制render树（paint），绘制页面像素信息

![](https://tva1.sinaimg.cn/large/00831rSTgy1gcrcf9nsy9j30p009sjrz.jpg)
### 1、构建DOM树
因为浏览器无法直接理解和使用html，所以需要将html转换为浏览器能够理解的结构——DOM树。

在渲染引擎内部，有一个叫 HTML 解析器（HTMLParser）的模块，它的职责就是负责将 HTML 字节流转换为 DOM 结构。
> Q:关于html 解析器是等整个 html 文档加载完成之后开始解析的，还是随着 html 文档边加载边解析的？
>
> A:一边接收一边解析。网络进程和渲染进程就像有个管道，网络进程一边往里面放，渲染进程一边读，并将其解析为DOM。

过程如下
```
Bytes → characters → tokens → nodes → DOM
```
![](https://tva1.sinaimg.cn/large/00831rSTgy1gcrch1s5r3j30p00dutav.jpg)
* 1、解码：浏览器将接收的字节流（Bytes）基于编码方式解析为字符（characters）
* 2、分词：通过分词器（也就是词法分析）将字符转换为 Token，分为Tag Token 和文本Token
* 3、tokens->nodes
* 4、nodes->DOM

第3步和第4步其实是同时进行的，需要将 Token 解析为 DOM 节点，并将 DOM 节点添加到 DOM 树中。

HTML 解析器维护了一个**Token栈结构**，该 Token 栈主要用来计算节点之间的父子关系，在第一个阶段中生成的 Token 会被按照顺序压到这个栈中。具体的处理规则如下所示：
* 如果压入到栈中的是**StartTag Token**，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的节点。

* 如果分词器解析出来是**文本 Token**，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 是不需要压入到栈中，它的父节点就是当前栈顶 Token 所对应的 DOM 节点。

* 如果分词器解析出来的是**EndTag 标签**，比如是 EndTag div，HTML 解析器会查看 Token 栈顶的元素是否是 StarTag div，如果是，就将 StartTag  div 从栈中弹出，表示该 div 元素解析完成。
通过分词器产生的新 Token 就这样不停地压栈和出栈，整个解析过程就这样一直持续下去，直到分词器将所有字节流分词完成。

#### JavaScript如何影响DOM的构建
在DOM树构建的中途，如果遇到script标签，解析器会停止解析 HTML（因为接下来的JavaScript 可能要修改当前已经生成的 DOM 结构），而去加载、解析和执行 JS 代码。
* **如果是内嵌JavaScript**

    直接执行脚本，执行完后HTML继续解析
* **如果是引入 JavaScript 文件**

    需要先下载JavaScript，下载过程也会阻塞DOM的渲染。下载速度受网络环境等诸多因素影响，通常比较慢。可以采取一些方案优化：

    * Chrome 浏览器针对这一点会进行预解析操作，也就是当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。

    * 也可以使用 CDN 来加速 JavaScript 文件的加载，压缩 JavaScript 文件的体积

    * 如果 JavaScript 文件中没有操作 DOM 相关代码，也可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码
    （async一旦加载完成，会立即执行；而defer需要在 DOMContentLoaded 事件之前执行）


### 2、构建CSS规则树
```
Bytes → characters → tokens → nodes → CSSOM
```
并根据继承、优先级层叠等规则生成如下CSS树：
![](https://tva1.sinaimg.cn/large/00831rSTgy1gcrci2zxr6j30g608b0tj.jpg)
#### CSS如何影响DOM的构建
通常我们认为CSS不会影响DOM的构建，因为它并不会操作或改变DOM，但是**CSS可以通过JavaScript来阻塞DOM的构建**。

因为JavaScript是可以改变样式的，也就是具有修改CSSOM的能力，而JavaScript脚本里是否有改变样式的操作，这一点在执行JavaScript之前是不可知的。因此，为保证JavaScript脚本的正确执行，在执行JavaScript之前，CSSOM必须要先准备好（不然万一有修改CSSOM的操作呢）。

也就是说，若在构建DOM的中途存在阻塞DOM构建的JavaScript脚本，而此页面中还包含了外部 CSS 文件的引用，或者通过 style 标签内置了 CSS 内容，那么此时就需要等目前的CSSOM（基于目前生成完的部分DOM树）构建完毕后，再开始JavaScript脚本的执行，等一切结束了，再继续DOM的构建。

整个流程如图：
![](https://tva1.sinaimg.cn/large/00831rSTgy1gcs95n94fkj30vq0djac9.jpg)

> 这个阶段最终输出的内容是每个DOM节点的样式，并被保存在 ComputedStyle 的结构内，通过浏览器的element->Computed可以查看

### 3、布局
我们已经有了DOM树和CSS树，但这不足以显示页面，因为还不知道元素的具体几何位置信息。因此此过程就是**计算DOM元素的几何位置**。
#### 3.1、构建render树
dom树中包含了很多页面渲染不需要的元素，比如head、dispaly:none的元素，因此显示之前需要再生成一棵只包含可见元素的render树
* 遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；
* 会忽略掉不可见元素
#### 3.2、布局render树
根据render树计算dom元素的具体几何位置（主要定位坐标和大小，是否换行，各种position overflow z-index属性。），计算完后，会将内容写入render树，也就是输出的是一个更详细带有位置新的render树。
![](https://tva1.sinaimg.cn/large/00831rSTgy1gcrckkqt5uj30p00bognc.jpg)

### 4、绘制render树
虽然现在我们已经有了详细的render树，但是还没到着手绘制页面的时候。
#### 分层
由于页面有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，因此渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树

要理解什么是图层，可以打开浏览器“开发者工具”的“Layers”标签，看看
![](https://tva1.sinaimg.cn/large/00831rSTgy1gdfely12onj30vq0tvdjx.jpg)
可以看到一个页面被分成了很多层，最终我们看到的画面是所有图层叠加在一起的结果。刚刚上面的图层叠加最终展示的页面如下图
![](https://tva1.sinaimg.cn/large/00831rSTgy1gdfenimz2nj30vq0o4dio.jpg)

**并不是布局树的每个节点都会单独分一层，只有特定类型的节点才会单独分层，如果没有单独分层的节点，就从属于其父节点的图层**。
![](https://tva1.sinaimg.cn/large/00831rSTgy1gcrcltzy7zj30vq0iqq4u.jpg)

那哪些特定的元素会生成单独的图层呢？

**1、拥有层叠上下文属性的元素**

如果用坐标系的角度来看一个页面，看我们看到的是一个x轴和y轴构成的页面，但实际上还有z轴，拥有层叠上下文的元素，在z轴上的位置是不同的
![](https://tva1.sinaimg.cn/large/00831rSTgy1gdfewv3uaoj30vq0gp0tj.jpg)

元素的透明度、明确定位属性的元素、CSS3的转换等这些都是拥有层叠上下文的，详细可参见[MDN-层叠上下文](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context)

**2、需要裁减的地方**

什么是裁减？
```html
<style>
      div {
            width: 200;
            height: 200;
            overflow:auto;
            background: gray;
        } 
</style>
<body>
    <div >
        <p>所以元素有了层叠上下文的属性或者需要被剪裁，那么就会被提升成为单独一层，你可以参看下图：</p>
        <p>从上图我们可以看到，document层上有A和B层，而B层之上又有两个图层。这些图层组织在一起也是一颗树状结构。</p>
        <p>图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创建层树（Update LayerTree）。</p> 
    </div>
</body>
```
打开“Layers”可以看到，文字部分超出了div的范围，是单独一个图层，而展示在div范围内的内容就是通过裁减后的。
![](https://tva1.sinaimg.cn/large/00831rSTgy1gdff8902t7j326n0u0dnj.jpg)
如果我们注释掉`overflow:auto`，则页面不存在裁减了，则会发现页面只有一层了
![](https://tva1.sinaimg.cn/large/00831rSTgy1gdff75644ij31w60nmgrp.jpg)

#### 图层绘制
分好层后，就需要对每个图层进行绘制了。绘制并不是一蹴而就，而是要一步步来，就和画画一样，先画蓝天作为背景，再画一个草地，再在草地上画一些小花....


渲染引擎也是类似，在绘制一个图层时，将一个图层的绘制拆分成很多小的绘制指令。
![](https://tva1.sinaimg.cn/large/00831rSTgy1gcrcm5stv2j30vq0grgnd.jpg)

还是刚刚的页面，，打开“开发者工具”的“Layers”标签，选择“document”层
![](https://tva1.sinaimg.cn/large/00831rSTgy1gdffftoshaj319o0u0aib.jpg)
左侧可以看到绘制指令，可以拖动右侧的进度条查看具体过程。
![](https://tva1.sinaimg.cn/large/00831rSTgy1gdffh0dzzlj31fw0u07ds.jpg)

**以上的绘制过程只是为每个图层形成了一系列的绘制指令，并没有真正的绘制出页面**，接下来就要开始真正的绘制页面了。而真正的绘制过程，是由渲染引擎中的合成线程来完成的。也就是当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程。
![](https://tva1.sinaimg.cn/large/00831rSTgy1gdffohc933j30vq0cwgnd.jpg)

#### 分块
完成了上面的步骤，此时渲染引擎的主线程已经将绘制指令提交给了合成线程，合成线程开始绘制页面。

有的页面很长，而用户一次性只能看到展示出来的一部分（也就是浏览器窗口的大小，我们称为“视口”），在这种情况下如果要将页面的所有图层的所有内容全部绘制出来，就会产生太大的开销，而且也没有必要。

基于这个原因，**合成线程会将图层分为图块**，这些图块的大小通常是 256x256 或者 512x512。
![](https://tva1.sinaimg.cn/large/00831rSTgy1gdffygciamj30vq0rndjd.jpg)

合成线程会优先绘制视口附近的图块，这一过程是由栅格化来实现的。


#### 栅格化

所谓栅格化，就是指**将图块转换为位图**。图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。
![](https://tva1.sinaimg.cn/large/00831rSTgy1gdfg3odz2jj30vq0it0v5.jpg)

通常，栅格化过程都是由GPU来加速生成的，生成的位图被保存在 GPU 内存中。而GPU操作时运行在GPU进程中，
因此如果栅格化使用了GPU，则会涉及到跨进程通信。
![](https://tva1.sinaimg.cn/large/00831rSTgy1gdfg60km8wj30vq0ntgop.jpg)

#### 合成
经过栅格化，此时绘制指令已经变成了一张张图片（一个图层对应一张图片），此时合成线程就会将这些图片合成为“一张”图片，并生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程，浏览器进程收到此命令，将其页面内容绘制到内存中。

#### 显示
图层合成完毕后生成了最终的页面，此时浏览器会把页面数据发送给显卡，由显卡来显示页面。我们先来看看**显卡的工作机制**。

显卡有前缓冲区和后缓冲区，每次接收到页面数据后，显卡会将其合成为新的图像，并保存进后缓冲区；一旦显卡将数据写入后缓冲区，系统就会调换前缓冲区和后缓冲区。显示器就是从显卡的前缓冲区读取最新合成的图像，并显示出来

大多数显示器的更新频率一般是60次/秒，也就意味着要想实现流畅的动画效果，显示器一秒钟得从显卡前缓冲区读取60张图片，那么显卡就得一秒钟存放60张图片进入后缓冲区。

我们把渲染流水线生成的每一张图片称为一帧，把渲染流水线每秒更新了多少帧称为帧率，比如滚动过程中 1 秒更新了 60 帧，那么帧率就是 60Hz（或者 60FPS）。如果页面太复杂，渲染引擎生成某些帧的时间过久，显卡一秒钟就收不到足够的帧数，那么显示器还是以不变的频率更新，但却读不到足够的图片，这时用户就会感觉到卡顿。

### 小结
至此，整个渲染过程就结束了，用一张图来概括一下。
![](https://tva1.sinaimg.cn/large/00831rSTgy1gdfjb4vxzxj313s0pkdis.jpg)

## 结束
渲染结束，渲染进程会通过IPC告知浏览器进程，停止展示tab的spinner

## 页面的变化
上面讲到的都是页面的背后发生了什么，那在这个过程中，我们所看到的页面是怎样变化的呢？主要有以下几个阶段：

* 第一个阶段: 旧页面。从输入url，到网络进程获取完数据，并向浏览进程发送”提交数据“的消息（也就是本文的获取资源阶段结束），页面都会保持为原页面。
> 第一阶段结束后，浏览器进程会**更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面（在此之前页面都还是展示的旧页面）**
* 第二个阶段: 白屏。提交数据之后渲染进程会创建一个空白页面，并等待 CSS 文件和 JavaScript 文件的加载完成，生成 CSSOM 和 DOM，然后合成布局树。

* 第三个阶段: 首帧渲染。布局树构建完成后，开始绘制，直到完成首帧渲染
> 第三阶段结束后，浏览器进程会停止展示tab的spinner（spinner在开始导航时，被改变为了记载中的loading状态）
* 第四个阶段: 完整页面渲染。等首次渲染完成之后，就开始进入完整页面的生成阶段了，然后页面会一点点被绘制出来。



## 参考
* [史上最全！图解浏览器的工作原理](https://www.infoq.cn/article/CS9-WZQlNR5h05HHDo1b)
* [一文读懂一个URL请求的过程是怎样的](https://juejin.im/post/5b83b0bfe51d4538c63131a8#heading-21)
* [从输入URL到页面加载的过程？如何由一道题完善自己的前端知识体系！](!https://juejin.im/post/5aa5cb846fb9a028e25d2fb1#comment)
* [从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理](https://segmentfault.com/a/1190000012925872#articleHeader16)
* [极客时间课程《浏览器工作原理与实践》](https://time.geekbang.org/column/article/117637)





